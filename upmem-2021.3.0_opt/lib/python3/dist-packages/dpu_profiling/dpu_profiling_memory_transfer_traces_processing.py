# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function
from collections import namedtuple
from dpu_profiling import Duration

import os
import sys
import argparse
import importlib

sys.path.append(os.environ['PERF_EXEC_PATH'] +
                '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *

TransferInfo = namedtuple(
    'TransferInfo',
    'start_ns end_ns size rank_path func_name')

rank_path = {}

# WRAM
wram_enter_nsecs = {}
wram_enter_secs = {}
wram_pid = {}

wram_write_infos = {}
wram_read_infos = {}

# MRAM
mram_enter_nsecs = {}
mram_enter_secs = {}
mram_pid = {}

mram_read_infos = {}
mram_write_infos = {}

# IRAM
iram_enter_nsecs = {}
iram_enter_secs = {}
iram_pid = {}

iram_write_infos = {}
iram_read_infos = {}

# xfer size
xfer_size = {}

# Unhandled events do not require specific treatment other than retrieving
# their duration.
unhandled_enter_nsecs = {}
unhandled_enter_secs = {}
unhandled_infos = {}
# But some unhandled are known, so prettify their name when displaying
pretty_type_unhandled = {
    "probe_libdpu__libdpu_dpu_switch_mux_for_rank": "MUX rank",
    "probe_libdpu__libdpu_dpu_switch_mux_for_dpu_line": "MUX dpu"}

# infos are stored per pid, linearize them.


def aggregate_infos(infos):
    infos_aggregate = []
    for infos_list in infos.values():
        infos_aggregate += infos_list

    return infos_aggregate


def trace_begin():
    module_results_parser.parse_init()


def trace_end():
    module_results_parser.parse_wram_write(aggregate_infos(wram_write_infos))
    module_results_parser.parse_wram_read(aggregate_infos(wram_read_infos))
    module_results_parser.parse_mram_write(aggregate_infos(mram_write_infos))
    module_results_parser.parse_mram_read(aggregate_infos(mram_read_infos))
    module_results_parser.parse_iram_write(aggregate_infos(iram_write_infos))
    module_results_parser.parse_iram_read(aggregate_infos(iram_read_infos))

    for func_name, unhandled_func_infos in unhandled_infos.items():
        pretty_type_name = pretty_type_unhandled[func_name] if func_name in pretty_type_unhandled else ""
        module_results_parser.parse_unhandled(
            aggregate_infos(unhandled_func_infos), pretty_type_name)

    module_results_parser.parse_end()


def probe_libdpu__libdpu_dpu_copy_to_wram_for_dpu_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid

    size = wram_pid[common_pid][0]
    path = rank_path[wram_pid[common_pid][1]]
    start_ns = Duration.nanoseconds(
        wram_enter_secs[common_pid],
        wram_enter_nsecs[common_pid])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)

    wram_write_infos.setdefault(common_pid, []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_to_wram_for_dpu"))


def probe_libdpu__libdpu_dpu_copy_to_wram_for_dpu(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, wram_word_offset, nb_of_words,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid

    wram_enter_nsecs[common_pid] = common_nsecs
    wram_enter_secs[common_pid] = common_secs
    wram_pid[common_pid] = (nb_of_words * 4, rank)


def probe_libdpu__libdpu_dpu_copy_from_wram_for_dpu_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid

    size = wram_pid[common_pid][0]
    path = rank_path[wram_pid[common_pid][1]]
    start_ns = Duration.nanoseconds(
        wram_enter_secs[common_pid],
        wram_enter_nsecs[common_pid])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)

    wram_read_infos.setdefault(common_pid, []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_from_wram_for_dpu"))


def probe_libdpu__libdpu_dpu_copy_from_wram_for_dpu(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, wram_word_offset, nb_of_words,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid

    wram_enter_nsecs[common_pid] = common_nsecs
    wram_enter_secs[common_pid] = common_secs
    wram_pid[common_pid] = (nb_of_words * 4, rank)


def probe_libdpu__libdpu_dpu_copy_to_wram_for_rank_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid

    size = wram_pid[common_pid][0]
    path = rank_path[wram_pid[common_pid][1]]
    start_ns = Duration.nanoseconds(
        wram_enter_secs[common_pid],
        wram_enter_nsecs[common_pid])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)

    wram_write_infos.setdefault(common_pid, []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_to_wram_for_rank"))


def probe_libdpu__libdpu_dpu_copy_to_wram_for_rank(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, nr_dpus_enabled, wram_word_offset, nb_of_words,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid

    wram_enter_nsecs[common_pid] = common_nsecs
    wram_enter_secs[common_pid] = common_secs
    wram_pid[common_pid] = (nb_of_words * 4 * nr_dpus_enabled, rank)


def probe_libdpuhw__libdpuhw_log_rank_path(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, path,
        perf_sample_dict):
    global rank_path
    rank_path[rank] = path


def probe_libdpu__libdpu_dpu_transfer_matrix_set_all(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        transfer_matrix,
        perf_sample_dict):
    global xfer_size
    xfer_size.setdefault(transfer_matrix, set()).clear()


def probe_libdpu__libdpu_dpu_transfer_matrix_add_dpu(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        dpu, transfer_matrix, buffer,
        perf_sample_dict):
    global xfer_size
    if buffer != 0:
        xfer_size.setdefault(transfer_matrix, set()).add(dpu)


def probe_libdpu__libdpu_dpu_transfer_matrix_clear_dpu(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        dpu, transfer_matrix,
        perf_sample_dict):
    global xfer_size
    xfer_size.setdefault(transfer_matrix, set()).discard(dpu)


def probe_libdpu__libdpu_dpu_transfer_matrix_clear_all(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        transfer_matrix,
        perf_sample_dict):
    global xfer_size
    xfer_size.setdefault(transfer_matrix, set()).clear()


def probe_libdpu__libdpu_dpu_transfer_matrix_copy(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        dst, src,
        perf_sample_dict):
    global xfer_size
    xfer_size[dst] = xfer_size.setdefault(src, set()).copy()


def probe_libdpu__libdpu_dpu_copy_to_mrams(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, transfer_matrix, size,
        perf_sample_dict):
    global mram_enter_secs, mram_enter_nsecs, mram_write_pid

    mram_enter_secs.setdefault(common_pid, {})[transfer_matrix] = common_secs
    mram_enter_nsecs.setdefault(common_pid, {})[transfer_matrix] = common_nsecs
    mram_pid[common_pid] = (transfer_matrix, rank, size)


def probe_libdpu__libdpu_dpu_copy_to_mrams_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global mram_enter_secs, mram_enter_nsecs, mram_pid, xfer_size
    global mram_write_infos
    global rank_path

    transfer_matrix = mram_pid[common_pid][0]
    path = rank_path[mram_pid[common_pid][1]]
    size = mram_pid[common_pid][2]
    start_ns = Duration.nanoseconds(
        mram_enter_secs[common_pid][transfer_matrix],
        mram_enter_nsecs[common_pid][transfer_matrix])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)

    nb_dpus = len(xfer_size[transfer_matrix])
    size *= nb_dpus

    mram_write_infos.setdefault(common_pid, []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_to_mrams_{}dpus".format(nb_dpus)))


def probe_libdpu__libdpu_dpu_copy_from_mrams(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, transfer_matrix, size,
        perf_sample_dict):
    global mram_enter_secs, mram_enter_nsecs, mram_pid

    mram_enter_secs.setdefault(common_pid, {})[transfer_matrix] = common_secs
    mram_enter_nsecs.setdefault(common_pid, {})[transfer_matrix] = common_nsecs
    mram_pid[common_pid] = (transfer_matrix, rank, size)


def probe_libdpu__libdpu_dpu_copy_from_mrams_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global mram_enter_secs, mram_enter_nsecs, mram_pid, xfer_size
    global mram_read_infos
    global rank_path

    transfer_matrix = mram_pid[common_pid][0]
    path = rank_path[mram_pid[common_pid][1]]
    size = mram_pid[common_pid][2]
    start_ns = Duration.nanoseconds(
        mram_enter_secs[common_pid][transfer_matrix],
        mram_enter_nsecs[common_pid][transfer_matrix])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)

    nb_dpus = len(xfer_size[transfer_matrix])
    size *= nb_dpus

    mram_read_infos.setdefault(common_pid, []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_from_mrams_{}dpus".format(nb_dpus)))


def probe_libdpu__libdpu_dpu_copy_to_iram_for_dpu_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global iram_enter_nsecs, iram_enter_secs, iram_pid

    size = iram_pid[common_pid][0]
    path = rank_path[iram_pid[common_pid][1]]
    start_ns = Duration.nanoseconds(
        iram_enter_secs[common_pid],
        iram_enter_nsecs[common_pid])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)

    iram_write_infos.setdefault(common_pid, []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_to_iram_for_dpu"))


def probe_libdpu__libdpu_dpu_copy_to_iram_for_dpu(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, iram_instruction_index, nb_of_instructions,
        perf_sample_dict):
    global iram_enter_nsecs, iram_enter_secs, iram_pid

    iram_enter_nsecs[common_pid] = common_nsecs
    iram_enter_secs[common_pid] = common_secs
    iram_pid[common_pid] = (nb_of_instructions, rank)


def probe_libdpu__libdpu_dpu_copy_to_iram_for_rank_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global iram_enter_nsecs, iram_enter_secs, iram_pid

    size = iram_pid[common_pid][0]
    path = rank_path[iram_pid[common_pid][1]]
    start_ns = Duration.nanoseconds(
        iram_enter_secs[common_pid],
        iram_enter_nsecs[common_pid])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)

    iram_write_infos.setdefault(common_pid, []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_to_iram_for_rank"))


def probe_libdpu__libdpu_dpu_copy_to_iram_for_rank(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, nr_dpus_enabled, iram_instruction_index, nb_of_instructions,
        perf_sample_dict):
    global iram_enter_nsecs, iram_enter_secs, iram_pid

    iram_enter_nsecs[common_pid] = common_nsecs
    iram_enter_secs[common_pid] = common_secs
    iram_pid[common_pid] = (nb_of_instructions * nr_dpus_enabled, rank)


def probe_libdpu__libdpu_dpu_copy_from_iram_for_dpu(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, iram_instruction_index, nb_of_instructions,
        perf_sample_dict):
    global iram_enter_nsecs, iram_enter_secs, iram_pid

    iram_enter_nsecs[common_pid] = common_nsecs
    iram_enter_secs[common_pid] = common_secs
    iram_pid[common_pid] = (nb_of_instructions, rank)


def probe_libdpu__libdpu_dpu_copy_from_iram_for_dpu_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global iram_enter_nsecs, iram_enter_secs, iram_pid

    size = iram_pid[common_pid][0]
    path = rank_path[iram_pid[common_pid][1]]
    start_ns = Duration.nanoseconds(
        iram_enter_secs[common_pid],
        iram_enter_nsecs[common_pid])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)

    iram_read_infos.setdefault(common_pid, []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_from_iram_for_dpu"))


def probe_libdpu__libdpu_dpu_copy_to_wram_for_matrix_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid, xfer_size

    transfer_matrix = wram_pid[common_pid][2]
    start_ns = Duration.nanoseconds(
        wram_enter_secs[common_pid],
        wram_enter_nsecs[common_pid])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)
    path = rank_path[wram_pid[common_pid][1]]
    nr_dpus = len(xfer_size[transfer_matrix])
    size = wram_pid[common_pid][0] * nr_dpus
    wram_write_infos.setdefault(
        common_pid,
        []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_to_wram_{}dpus".format(nr_dpus)))


def probe_libdpu__libdpu_dpu_copy_from_wram_for_matrix_exit__return(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_func, __probe_ret_ip,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid, xfer_size

    transfer_matrix = wram_pid[common_pid][2]
    start_ns = Duration.nanoseconds(
        wram_enter_secs[common_pid],
        wram_enter_nsecs[common_pid])
    end_ns = Duration.nanoseconds(common_secs, common_nsecs)
    path = rank_path[wram_pid[common_pid][1]]
    nr_dpus = len(xfer_size[transfer_matrix])
    size = wram_pid[common_pid][0] * nr_dpus
    wram_read_infos.setdefault(
        common_pid,
        []).append(
        TransferInfo(
            start_ns,
            end_ns,
            size,
            path,
            "dpu_copy_from_wram_{}dpus".format(nr_dpus)))


def probe_libdpu__libdpu_dpu_copy_to_wram_for_matrix(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, transfer_matrix, size,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid
    wram_enter_nsecs[common_pid] = common_nsecs
    wram_enter_secs[common_pid] = common_secs
    wram_pid[common_pid] = (size * 4, rank, transfer_matrix)


def probe_libdpu__libdpu_dpu_copy_from_wram_for_matrix(
        event_name, context, common_cpu, common_secs, common_nsecs,
        common_pid, common_comm, common_callchain,
        __probe_ip,
        rank, transfer_matrix, size,
        perf_sample_dict):
    global wram_enter_nsecs, wram_enter_secs, wram_pid
    wram_enter_nsecs[common_pid] = common_nsecs
    wram_enter_secs[common_pid] = common_secs
    wram_pid[common_pid] = (size * 4, rank, transfer_matrix)


# For all unhandled functions, display their duration.


def trace_unhandled(event_name, context, event_fields_dict, perf_sample_dict):
    global unhandled_enter_secs, unhandled_enter_nsecs
    global unhandled_infos

    if event_name not in unhandled_enter_nsecs:
        unhandled_enter_nsecs[event_name] = {}
        unhandled_enter_secs[event_name] = {}
        unhandled_infos[event_name] = {}

    common_pid = event_fields_dict["common_pid"]
    common_secs = event_fields_dict["common_s"]
    common_nsecs = event_fields_dict["common_ns"]

    if "exit__return" not in event_name:
        unhandled_enter_nsecs[event_name][common_pid] = common_nsecs
        unhandled_enter_secs[event_name][common_pid] = common_secs
    else:
        func_name = event_name.replace("_exit__return", "")

        start_ns = Duration.nanoseconds(
            unhandled_enter_secs[func_name][common_pid],
            unhandled_enter_nsecs[func_name][common_pid])
        end_ns = Duration.nanoseconds(common_secs, common_nsecs)

        if common_pid not in unhandled_infos[func_name]:
            unhandled_infos[func_name][common_pid] = []

        unhandled_infos[func_name][common_pid].append(
            TransferInfo(start_ns, end_ns, 0, 0, func_name))


def print_header(event_name, cpu, secs, nsecs, pid, comm):
    print("%-20s %5u %05u.%09u %8u %-20s " %
          (event_name, cpu, secs, nsecs, pid, comm), end="")


def get_dict_as_string(a_dict, delimiter=' '):
    return delimiter.join(['%s=%s' % (k, str(v))
                           for k, v in sorted(a_dict.items())])


parser = argparse.ArgumentParser(description='Raw profiling results')
parser.add_argument('--result-parser', default="dpu_profiling_print_summary",
                    help='Path to python result parser script')
args = parser.parse_args()

module_results_parser = importlib.import_module(args.result_parser)
