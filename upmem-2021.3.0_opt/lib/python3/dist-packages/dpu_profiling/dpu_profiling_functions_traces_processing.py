# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function
from collections import namedtuple
from dpu_profiling import Duration

import os
import sys
import argparse
import importlib

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
        '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *

FunctionDurationInfo = namedtuple('FunctionDurationInfo', 'start_ns end_ns func_name')

# Unhandled events do not require specific treatment other than retrieving
# their duration.
unhandled_enter_nsecs = {}
unhandled_enter_secs = {}
unhandled_infos = {}
# But some unhandled are known, so prettify their name when displaying
pretty_type_unhandled = {}

# infos are stored per pid, linearize them.
def aggregate_infos(infos):
        infos_aggregate = []
        for pid, infos_list in infos.items():
            for xfer_info in infos_list:
                infos_aggregate.append(xfer_info)

        return infos_aggregate

def trace_begin():
        module_results_parser.parse_init()

def trace_end():
        for func_name, unhandled_func_infos in unhandled_infos.items():
            if func_name in pretty_type_unhandled:
                pretty_type_name = pretty_type_unhandled[func_name]
            else:
                pretty_type_name = ""

            module_results_parser.parse_unhandled(aggregate_infos(unhandled_func_infos), pretty_type_name)

        module_results_parser.parse_end()

# For all unhandled functions, display their duration.
def trace_unhandled(event_name, context, event_fields_dict, perf_sample_dict):
        global unhandled_enter_secs, unhandled_enter_nsecs
        global unhandled_infos

        if event_name not in unhandled_enter_nsecs:
            unhandled_enter_nsecs[event_name] = {}
            unhandled_enter_secs[event_name] = {}
            unhandled_infos[event_name] = {}

        common_pid = event_fields_dict["common_pid"]
        common_secs = event_fields_dict["common_s"]
        common_nsecs = event_fields_dict["common_ns"]

        if "exit__return" not in event_name:
            unhandled_enter_nsecs[event_name][common_pid] = common_nsecs
            unhandled_enter_secs[event_name][common_pid] = common_secs
        else:
            func_name = event_name.replace("_exit__return", "")

            start_ns = Duration.nanoseconds(unhandled_enter_secs[func_name][common_pid],
                                                unhandled_enter_nsecs[func_name][common_pid])
            end_ns = Duration.nanoseconds(common_secs, common_nsecs)

            if common_pid not in unhandled_infos[func_name]:
                unhandled_infos[func_name][common_pid] = []

            unhandled_infos[func_name][common_pid].append(FunctionDurationInfo(start_ns, end_ns, func_name))

def print_header(event_name, cpu, secs, nsecs, pid, comm):
        print("%-20s %5u %05u.%09u %8u %-20s " % \
        (event_name, cpu, secs, nsecs, pid, comm), end="")

def get_dict_as_string(a_dict, delimiter=' '):
        return delimiter.join(['%s=%s'%(k,str(v))for k,v in sorted(a_dict.items())])


parser = argparse.ArgumentParser(description = 'Raw profiling results')
parser.add_argument('--result-parser', default = "dpu_profiling_print_functions",
                help = 'Path to python result parser script')
args = parser.parse_args()

module_results_parser = importlib.import_module(args.result_parser)
