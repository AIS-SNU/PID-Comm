#!/usr/bin/env python3
import sys
import argparse
import json
import os

def remove_duplicate(root):
	print("* Removing duplicates...")

	funcs = {}
	new_trace_events = []

	for ctf_event in root["traceEvents"]:
		# Do not format non-sample events.
		if ctf_event["ph"] == "I":
			if ctf_event["ts"] == 0.0:
				root["traceEvents"].remove(ctf_event)
			continue;

		event_name = ctf_event["name"].split(":")[1]
		if "__entry" in event_name:
			func_name = event_name.replace("__entry", "")
		elif "__exit__return" in event_name:
			func_name = event_name.replace("__exit__return", "")
		else:
			continue
		tid = ctf_event["tid"]
		if tid not in funcs:
			funcs[tid] = {}

		if func_name not in funcs[tid]:
			funcs[tid][func_name] = False

		if "__entry" in event_name:
			#if funcs[tid][func_name] == True:
			#	root["traceEvents"].remove(ctf_event)
			if funcs[tid][func_name] == False:
				new_trace_events.append(ctf_event)
			funcs[tid][func_name] = True
		elif "__exit__return" in event_name:
			#if funcs[tid][func_name] == False:
			#	root["traceEvents"].remove(ctf_event)
			if funcs[tid][func_name] == True:
				new_trace_events.append(ctf_event)
			funcs[tid][func_name] = False

	root["traceEvents"][:] = new_trace_events

def duplicate_rank_events(root):
	print("* Duplicate rank events...")

	funcs = {}
	new_trace_events = []
	nr_ranks = 0
	ranks_id = {}

	for ctf_event in root["traceEvents"]:
		# Do not format non-sample events.
		if ctf_event["ph"] == "I":
			if ctf_event["ts"] == 0.0:
				root["traceEvents"].remove(ctf_event)
			continue;

		event_name = ctf_event["name"].split(":")[1]
		if "__entry" in event_name:
			func_name = event_name.replace("__entry", "")
		elif "__exit__return" in event_name:
			func_name = event_name.replace("__exit__return", "")
		else:
			continue
		tid = ctf_event["tid"]
		if tid not in funcs:
			funcs[tid] = {}

		if func_name not in funcs[tid]:
			funcs[tid][func_name] = None

		new_trace_events.append(ctf_event)
		if "__entry" in event_name:
			if funcs[tid][func_name] is None:
				if not "rank" in ctf_event["args"]:
					continue
				rank = ctf_event["args"]["rank"]
				if not rank in ranks_id:
					ranks_id[rank] = nr_ranks
					nr_ranks += 1
				funcs[tid][func_name] = ranks_id[rank]
				event = dict(ctf_event)
				event["tid"] = funcs[tid][func_name]
				new_trace_events.append(event)
		elif "__exit__return" in event_name:
			if funcs[tid][func_name] is not None:
				event = dict(ctf_event)
				event["tid"] = funcs[tid][func_name]
				new_trace_events.append(event)
				funcs[tid][func_name] = None

	root["traceEvents"][:] = new_trace_events

def limit_call_depth(root, call_depth):
	print("* Limiting call depth...")

	new_trace_events = []

	if call_depth != sys.maxsize:
		beginning_level = {}
		for ctf_event in root["traceEvents"]:
			tid = ctf_event["tid"]
			name = ctf_event["name"]

			if tid not in beginning_level:
				beginning_level[tid] = 0

			if ctf_event["ph"] == 'B' and "libdpu" in name:
				beginning_level[tid] += 1
			if beginning_level[tid] <= call_depth or ctf_event["ph"] == "I":
				new_trace_events.append(ctf_event)
			if ctf_event["ph"] == 'E' and "libdpu" in name:
				beginning_level[tid] -= 1

		root["traceEvents"][:] = new_trace_events


def pretty_print(root):
	print("* Pretty printing...")

	new_trace_events = []

	for ctf_event in root["traceEvents"]:
		# Do not format non-sample events.
		if ctf_event["ph"] == "I":
			continue

		lib_name = ctf_event["name"].split(":")[0].replace("probe_", "")
		event_name = ctf_event["name"].split(":")[1]
		func_name = event_name.replace("{}_".format(lib_name), "")
		func_name = func_name.replace("__entry", "")
		ctf_event["name"] = func_name

		new_trace_events.append(ctf_event)

	root["traceEvents"][:] = new_trace_events

def json_load(input_json):
	print("* Loading json...")
	with open(input_json, "r") as f:
		input_json_content = f.read()

	return json.loads(input_json_content)

def json_dump(output_json, root):
	print("* Dumping json...")
	with open(output_json, "w") as f:
		f.write(json.dumps(root))

# Important: we expect the traces to be sorted by timestamps
def post_process_json_file(input_json, output_json, call_depth, group_rank_events):
	print("Post-processing traces, this can take a few minutes...")

	root = json_load(input_json)

	# Let's remove duplicate events generated by a buggy perf and non-sample
	# events with null timestamp.
	remove_duplicate(root)

	if group_rank_events:
		duplicate_rank_events(root)

	# Limit call depth to the value asked by the user
	limit_call_depth(root, call_depth)
	# Pretty the printed name which is too long ("probe_XXX:XXX_function")
	pretty_print(root)

	json_dump(output_json, root)


if __name__ == '__main__':
	parser = argparse.ArgumentParser(description = 'Post process traces')
	parser.add_argument('--output', default = "out_without_dup.json",
			    help = 'Output perf event duplicates json file')
	parser.add_argument('--call-depth-in-api', default = sys.maxsize, type = int,
			    help = 'Call depth limit in UPMEM API, default is unlimited')
	parser.add_argument('--group-rank-events', action='store_true',
			    help = 'Group rank related events by rank')
	parser.add_argument("input", help = "Path to the json chrome trace format file")

	args = parser.parse_args()
	post_process_json_file(args.input, args.output, args.call_depth_in_api, args.group_rank_events)
